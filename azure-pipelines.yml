# Umbraco.Ai Monorepo CI/CD Pipeline
# Supports independent versioning and building per product

trigger:
  branches:
    include:
      - main
      - dev
      - release/*
      - hotfix/*
  tags:
    include:
      - release-*

pr:
  branches:
    include:
      - main
      - dev

# Pipeline variables
variables:
  - name: configuration
    value: 'Release'
  - name: vmImage
    value: 'ubuntu-latest'

stages:
  # Stage 1: Detect Changes
  - stage: DetectChanges
    displayName: 'Detect Changed Products'
    jobs:
      - job: DetectChanges
        displayName: 'Analyze changes and set variables'
        pool:
          vmImage: $(vmImage)

        steps:
          - checkout: self
            fetchDepth: 2  # Need last 2 commits for diff

          - task: PowerShell@2
            name: detectChanges
            displayName: 'Run change detection'
            inputs:
              filePath: '$(Build.SourcesDirectory)/build/scripts/detect-changes.ps1'
              arguments: '-SourceBranch "$(Build.SourceBranch)" -SourceVersion "$(Build.SourceVersion)"'

  # Debug stage to verify variables
  - stage: DebugVariables
    displayName: 'Debug Output Variables'
    dependsOn: DetectChanges
    jobs:
      - job: ShowVariables
        displayName: 'Show detected variables'
        pool:
          vmImage: $(vmImage)
        variables:
          Level0Changed: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level0Changed'] ]
          Level1Changed: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level1Changed'] ]
          Level0Matrix: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level0Matrix'] ]
          Level1Matrix: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level1Matrix'] ]
        steps:
          - task: PowerShell@2
            displayName: 'Display variables'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "=== Output Variables from DetectChanges ==="
                Write-Host "Level0Changed: '$(Level0Changed)'"
                Write-Host "Level0Changed type: $('$(Level0Changed)'.GetType().Name)"
                Write-Host "Level0Changed length: $('$(Level0Changed)'.Length)"
                Write-Host ""
                Write-Host "Level1Changed: '$(Level1Changed)'"
                Write-Host ""
                Write-Host "Testing condition expression:"
                $level0 = '$(Level0Changed)'
                Write-Host "  Variable value: '$level0'"
                Write-Host "  eq(level0, 'true'): $($level0 -eq 'true')"
                Write-Host "  eq(level0, 'True'): $($level0 -eq 'True')"
                Write-Host "  Trimmed: '$($level0.Trim())'"
                Write-Host ""
                Write-Host "Level0Matrix:"
                Write-Host "$(Level0Matrix)"
                Write-Host ""
                Write-Host "Level1Matrix:"
                Write-Host "$(Level1Matrix)"

  # Stage 2-6: Build Products by Dependency Level (DYNAMIC)
  # Products are automatically discovered and built based on detect-changes.ps1 output
  # Products at each level are built in parallel using matrix strategy
  # Level 0 = no dependencies, Level 1 = depends on Level 0, etc.

  - stage: BuildLevel0
    displayName: 'Build Level 0 (No Dependencies)'
    dependsOn: DetectChanges
    jobs:
      - job: Build_Level_0
        displayName: 'Build Level 0 Products'
        pool:
          vmImage: $(vmImage)
        variables:
          Level0Changed: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level0Changed'] ]
          productName: $(name)
          productPath: $(path)
          hasFrontend: $(hasFrontend)
        condition: eq(variables['Level0Changed'], 'true')
        strategy:
          matrix: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level0Matrix'] ]
        steps:
          - task: PowerShell@2
            displayName: 'Debug: Show variables'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Level0Changed: '$(Level0Changed)'"
                Write-Host "Building product: $(productName) at $(productPath)"
                Write-Host "Has frontend: $(hasFrontend)"

          - template: build/templates/build-steps.yml
            parameters:
              configuration: $(configuration)

  - stage: BuildLevel1
    displayName: 'Build Level 1'
    dependsOn:
      - DetectChanges
      - BuildLevel0
    jobs:
      - job: Build_Level_1
        displayName: 'Build Level 1 Products'
        pool:
          vmImage: $(vmImage)
        variables:
          Level1Changed: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level1Changed'] ]
          productName: $(name)
          productPath: $(path)
          hasFrontend: $(hasFrontend)
        condition: eq(variables['Level1Changed'], 'true')
        strategy:
          matrix: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level1Matrix'] ]
        steps:
          - template: build/templates/build-steps.yml
            parameters:
              configuration: $(configuration)

  - stage: BuildLevel2
    displayName: 'Build Level 2'
    dependsOn:
      - DetectChanges
      - BuildLevel1
    jobs:
      - job: Build_Level_2
        displayName: 'Build Level 2 Products'
        pool:
          vmImage: $(vmImage)
        variables:
          Level2Changed: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level2Changed'] ]
          productName: $(name)
          productPath: $(path)
          hasFrontend: $(hasFrontend)
        condition: eq(variables['Level2Changed'], 'true')
        strategy:
          matrix: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level2Matrix'] ]
        steps:
          - template: build/templates/build-steps.yml
            parameters:
              configuration: $(configuration)

  - stage: BuildLevel3
    displayName: 'Build Level 3'
    dependsOn:
      - DetectChanges
      - BuildLevel2
    jobs:
      - job: Build_Level_3
        displayName: 'Build Level 3 Products'
        pool:
          vmImage: $(vmImage)
        variables:
          Level3Changed: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level3Changed'] ]
          productName: $(name)
          productPath: $(path)
          hasFrontend: $(hasFrontend)
        condition: eq(variables['Level3Changed'], 'true')
        strategy:
          matrix: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level3Matrix'] ]
        steps:
          - template: build/templates/build-steps.yml
            parameters:
              configuration: $(configuration)

  - stage: BuildLevel4
    displayName: 'Build Level 4'
    dependsOn:
      - DetectChanges
      - BuildLevel3
    jobs:
      - job: Build_Level_4
        displayName: 'Build Level 4 Products'
        pool:
          vmImage: $(vmImage)
        variables:
          Level4Changed: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level4Changed'] ]
          productName: $(name)
          productPath: $(path)
          hasFrontend: $(hasFrontend)
        condition: eq(variables['Level4Changed'], 'true')
        strategy:
          matrix: $[ stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.Level4Matrix'] ]
        steps:
          - template: build/templates/build-steps.yml
            parameters:
              configuration: $(configuration)

  # Stage 7: Run Tests (Parallel)
  - stage: Test
    displayName: 'Run Tests'
    dependsOn:
      - BuildLevel0
      - BuildLevel1
      - BuildLevel2
      - BuildLevel3
      - BuildLevel4
    jobs:
      - job: TestCore
        displayName: 'Test Umbraco.Ai (Core)'
        pool:
          vmImage: $(vmImage)
        condition: eq(stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.CoreChanged'], 'true')
        steps:
          - task: DotNetCoreCLI@2
            displayName: 'Run Core tests'
            inputs:
              command: 'test'
              projects: 'Umbraco.Ai/Umbraco.Ai.sln'
              arguments: '--configuration $(configuration) --collect:"XPlat Code Coverage"'

          - task: PublishCodeCoverageResults@2
            displayName: 'Publish code coverage'
            inputs:
              summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'

      - job: TestAgent
        displayName: 'Test Umbraco.Ai.Agent'
        pool:
          vmImage: $(vmImage)
        condition: eq(stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.AgentChanged'], 'true')
        steps:
          - task: DotNetCoreCLI@2
            displayName: 'Run Agent tests'
            inputs:
              command: 'test'
              projects: 'Umbraco.Ai.Agent/Umbraco.Ai.Agent.sln'
              arguments: '--configuration $(configuration)'

      - job: TestPrompt
        displayName: 'Test Umbraco.Ai.Prompt'
        pool:
          vmImage: $(vmImage)
        condition: eq(stageDependencies.DetectChanges.DetectChanges.outputs['detectChanges.PromptChanged'], 'true')
        steps:
          - task: DotNetCoreCLI@2
            displayName: 'Run Prompt tests'
            inputs:
              command: 'test'
              projects: 'Umbraco.Ai.Prompt/Umbraco.Ai.Prompt.sln'
              arguments: '--configuration $(configuration)'

  # Stage 4: Deploy to MyGet (optional, requires variable group)
  # - stage: DeployMyGet
  #   displayName: 'Deploy to MyGet'
  #   dependsOn: Test
  #   condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
  #   jobs:
  #     - job: Deploy
  #       displayName: 'Push packages to MyGet'
  #       pool:
  #         vmImage: $(vmImage)
  #       steps:
  #         - task: DownloadPipelineArtifact@2
  #           displayName: 'Download all artifacts'
  #           inputs:
  #             downloadPath: '$(Pipeline.Workspace)/artifacts'
  #
  #         - task: NuGetCommand@2
  #           displayName: 'Push to MyGet'
  #           inputs:
  #             command: 'push'
  #             packagesToPush: '$(Pipeline.Workspace)/artifacts/**/*.nupkg'
  #             nuGetFeedType: 'external'
  #             publishFeedCredentials: 'MyGet-Umbraco-Ai'

  # Stage 5: Deploy to NuGet (release tags only)
  # - stage: DeployNuGet
  #   displayName: 'Deploy to NuGet'
  #   dependsOn: Test
  #   condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/tags/release-'))
  #   jobs:
  #     - job: Deploy
  #       displayName: 'Push packages to NuGet'
  #       pool:
  #         vmImage: $(vmImage)
  #       steps:
  #         - task: DownloadPipelineArtifact@2
  #           displayName: 'Download all artifacts'
  #           inputs:
  #             downloadPath: '$(Pipeline.Workspace)/artifacts'
  #
  #         - task: NuGetCommand@2
  #           displayName: 'Push to NuGet'
  #           inputs:
  #             command: 'push'
  #             packagesToPush: '$(Pipeline.Workspace)/artifacts/**/*.nupkg'
  #             nuGetFeedType: 'external'
  #             publishFeedCredentials: 'NuGet-Umbraco-Ai'
