# Azure DevOps CI Pipeline for Umbraco.Ai
# Converted from GitHub Actions (.github/workflows/ci.yml)

trigger:
  branches:
    include:
      - main
      - dev
      - release/*
      - hotfix/*
  tags:
    include:
      - release-*

pr:
  branches:
    include:
      - main
      - dev

variables:
  NODE_VERSION: '20.x'
  DOTNET_NOLOGO: 'true'
  DOTNET_CLI_TELEMETRY_OPTOUT: 'true'

stages:
  # ============================================================
  # Build & Test everything
  # ============================================================
  - stage: Build
    displayName: Build & Test
    jobs:
      - job: BuildAndTest
        displayName: Build & Test
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - task: UseDotNet@2
            displayName: Setup .NET
            inputs:
              useGlobalJson: true

          - task: NodeTool@0
            displayName: Setup Node.js
            inputs:
              versionSpec: $(NODE_VERSION)

          - script: |
              npm ci
              npm run build
            displayName: Build frontend

          - script: dotnet restore Umbraco.Ai.sln
            displayName: Restore

          - script: dotnet build Umbraco.Ai.sln --configuration Release --no-restore
            displayName: Build

          - script: dotnet test Umbraco.Ai.sln --configuration Release --no-build --verbosity normal --logger trx --results-directory $(Agent.TempDirectory)/TestResults
            displayName: Test

          - task: PublishTestResults@2
            displayName: Publish test results
            condition: always()
            inputs:
              testResultsFormat: VSTest
              testResultsFiles: '$(Agent.TempDirectory)/TestResults/**/*.trx'
              mergeTestResults: true

          - task: PublishPipelineArtifact@1
            displayName: Upload build outputs
            inputs:
              targetPath: $(Build.SourcesDirectory)
              artifact: build-outputs
              publishLocation: pipeline

  # ============================================================
  # Pack Stage - Only runs on push to main/dev or release tags
  # Uses dynamic change detection to only pack products that changed
  # ============================================================
  - stage: Pack
    displayName: Pack NuGet Packages
    dependsOn: Build
    # Only pack on push (not PR) to main/dev branches or release tags
    condition: |
      and(
        succeeded(),
        ne(variables['Build.Reason'], 'PullRequest'),
        or(
          startsWith(variables['Build.SourceBranch'], 'refs/tags/release-'),
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          eq(variables['Build.SourceBranch'], 'refs/heads/dev')
        )
      )
    jobs:
      # ============================================================
      # Detect which products changed
      # ============================================================
      - job: DetectChanges
        displayName: Detect Changed Products
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - task: PowerShell@2
            displayName: Run change detection
            name: detect
            inputs:
              filePath: .azure-pipelines/scripts/detect-changes.ps1
              pwsh: true

      # ============================================================
      # Pack Level 0 (Core - no internal dependencies)
      # Dynamic matrix based on change detection
      # ============================================================
      - job: PackLevel0
        displayName: Pack Level 0
        dependsOn: DetectChanges
        condition: eq(dependencies.DetectChanges.outputs['detect.Level0Changed'], 'true')
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          matrix: $[ dependencies.DetectChanges.outputs['detect.Level0Matrix'] ]
          maxParallel: 1
        steps:
          - checkout: self
            fetchDepth: 0

          - task: UseDotNet@2
            displayName: Setup .NET
            inputs:
              useGlobalJson: true

          - task: DownloadPipelineArtifact@2
            displayName: Download build outputs
            inputs:
              artifact: build-outputs
              path: $(Build.SourcesDirectory)

          - template: .azure-pipelines/templates/pack-product.yml
            parameters:
              product: $(name)

          - task: PublishPipelineArtifact@1
            displayName: Upload $(name) packages
            inputs:
              targetPath: $(Build.SourcesDirectory)/artifacts/nupkg
              artifact: $(name)-packages
              publishLocation: pipeline

      # ============================================================
      # Pack Level 1 (Providers + Add-ons - depend on Core)
      # Dynamic matrix based on change detection
      # ============================================================
      - job: PackLevel1
        displayName: Pack Level 1
        dependsOn:
          - DetectChanges
          - PackLevel0
        condition: |
          and(
            not(failed()),
            not(canceled()),
            eq(dependencies.DetectChanges.outputs['detect.Level1Changed'], 'true')
          )
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          matrix: $[ dependencies.DetectChanges.outputs['detect.Level1Matrix'] ]
          maxParallel: 10
        variables:
          Level0Products: $[ dependencies.DetectChanges.outputs['detect.Level0Products'] ]
        steps:
          - checkout: self
            fetchDepth: 0

          - task: UseDotNet@2
            displayName: Setup .NET
            inputs:
              useGlobalJson: true

          - task: DownloadPipelineArtifact@2
            displayName: Download build outputs
            inputs:
              artifact: build-outputs
              path: $(Build.SourcesDirectory)

          # Download Level 0 packages as local feed (if any were packed)
          - task: Bash@3
            displayName: Download Level 0 packages
            condition: ne(variables.Level0Products, '')
            inputs:
              targetType: inline
              script: |
                set -e
                mkdir -p artifacts/nupkg

                IFS=',' read -ra PRODUCTS <<< "$(Level0Products)"
                for product in "${PRODUCTS[@]}"; do
                  echo "Downloading $product packages..."
                  # Use Azure DevOps REST API to download artifact
                  az pipelines runs artifact download \
                    --artifact-name "${product}-packages" \
                    --path "$(Build.SourcesDirectory)/artifacts/nupkg" \
                    --run-id $(Build.BuildId) \
                    --organization "$(System.CollectionUri)" \
                    --project "$(System.TeamProject)" 2>/dev/null || echo "Artifact ${product}-packages not found or already downloaded"
                done

                echo "Downloaded packages:"
                ls -la artifacts/nupkg/ 2>/dev/null || echo "(empty)"
            env:
              AZURE_DEVOPS_EXT_PAT: $(System.AccessToken)

          - template: .azure-pipelines/templates/pack-product.yml
            parameters:
              product: $(name)

          - task: PublishPipelineArtifact@1
            displayName: Upload $(name) packages
            inputs:
              targetPath: $(Build.SourcesDirectory)/artifacts/nupkg
              artifact: $(name)-packages
              publishLocation: pipeline

      # ============================================================
      # Pack Level 2 (Future packages that depend on Level 1)
      # Dynamic matrix based on change detection
      # ============================================================
      - job: PackLevel2
        displayName: Pack Level 2
        dependsOn:
          - DetectChanges
          - PackLevel0
          - PackLevel1
        condition: |
          and(
            not(failed()),
            not(canceled()),
            eq(dependencies.DetectChanges.outputs['detect.Level2Changed'], 'true')
          )
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          matrix: $[ dependencies.DetectChanges.outputs['detect.Level2Matrix'] ]
          maxParallel: 10
        variables:
          Level0Products: $[ dependencies.DetectChanges.outputs['detect.Level0Products'] ]
          Level1Products: $[ dependencies.DetectChanges.outputs['detect.Level1Products'] ]
        steps:
          - checkout: self
            fetchDepth: 0

          - task: UseDotNet@2
            displayName: Setup .NET
            inputs:
              useGlobalJson: true

          - task: DownloadPipelineArtifact@2
            displayName: Download build outputs
            inputs:
              artifact: build-outputs
              path: $(Build.SourcesDirectory)

          # Download Level 0 and Level 1 packages as local feed
          - task: Bash@3
            displayName: Download dependency packages
            inputs:
              targetType: inline
              script: |
                set -e
                mkdir -p artifacts/nupkg

                # Download Level 0 packages
                if [ -n "$(Level0Products)" ]; then
                  IFS=',' read -ra PRODUCTS <<< "$(Level0Products)"
                  for product in "${PRODUCTS[@]}"; do
                    echo "Downloading $product packages (Level 0)..."
                    az pipelines runs artifact download \
                      --artifact-name "${product}-packages" \
                      --path "$(Build.SourcesDirectory)/artifacts/nupkg" \
                      --run-id $(Build.BuildId) \
                      --organization "$(System.CollectionUri)" \
                      --project "$(System.TeamProject)" 2>/dev/null || echo "Artifact ${product}-packages not found"
                  done
                fi

                # Download Level 1 packages
                if [ -n "$(Level1Products)" ]; then
                  IFS=',' read -ra PRODUCTS <<< "$(Level1Products)"
                  for product in "${PRODUCTS[@]}"; do
                    echo "Downloading $product packages (Level 1)..."
                    az pipelines runs artifact download \
                      --artifact-name "${product}-packages" \
                      --path "$(Build.SourcesDirectory)/artifacts/nupkg" \
                      --run-id $(Build.BuildId) \
                      --organization "$(System.CollectionUri)" \
                      --project "$(System.TeamProject)" 2>/dev/null || echo "Artifact ${product}-packages not found"
                  done
                fi

                echo "Downloaded packages:"
                ls -la artifacts/nupkg/ 2>/dev/null || echo "(empty)"
            env:
              AZURE_DEVOPS_EXT_PAT: $(System.AccessToken)

          - template: .azure-pipelines/templates/pack-product.yml
            parameters:
              product: $(name)

          - task: PublishPipelineArtifact@1
            displayName: Upload $(name) packages
            inputs:
              targetPath: $(Build.SourcesDirectory)/artifacts/nupkg
              artifact: $(name)-packages
              publishLocation: pipeline

      # ============================================================
      # Collect all packages into single artifact
      # Dynamically downloads only changed product artifacts
      # ============================================================
      - job: CollectPackages
        displayName: Collect All Packages
        dependsOn:
          - DetectChanges
          - PackLevel0
          - PackLevel1
          - PackLevel2
        condition: |
          and(
            not(failed()),
            not(canceled()),
            eq(dependencies.DetectChanges.outputs['detect.AnyChanged'], 'true')
          )
        pool:
          vmImage: 'ubuntu-latest'
        variables:
          AllChangedProducts: $[ dependencies.DetectChanges.outputs['detect.AllChangedProducts'] ]
        steps:
          - task: Bash@3
            displayName: Download all changed package artifacts
            inputs:
              targetType: inline
              script: |
                set -e
                mkdir -p all-packages

                if [ -z "$(AllChangedProducts)" ]; then
                  echo "No changed products to collect"
                  exit 0
                fi

                # Parse comma-separated product list
                IFS=',' read -ra PRODUCTS <<< "$(AllChangedProducts)"

                for product in "${PRODUCTS[@]}"; do
                  echo "Downloading ${product}-packages..."

                  # Use Azure DevOps REST API to download artifact
                  artifact_url="$(System.CollectionUri)$(System.TeamProject)/_apis/build/builds/$(Build.BuildId)/artifacts?artifactName=${product}-packages&api-version=7.0&\$format=zip"

                  curl -s -L \
                    -H "Authorization: Bearer $(System.AccessToken)" \
                    "$artifact_url" \
                    -o "${product}-packages.zip"

                  if [ -f "${product}-packages.zip" ] && [ -s "${product}-packages.zip" ]; then
                    unzip -o "${product}-packages.zip" -d all-packages/ || echo "Warning: Failed to unzip ${product}-packages.zip"
                    rm -f "${product}-packages.zip"
                  else
                    echo "Warning: Artifact ${product}-packages not found or empty"
                    rm -f "${product}-packages.zip"
                  fi
                done

                # Flatten directory structure (artifacts extract to subdirs)
                find all-packages -name "*.nupkg" -exec mv {} all-packages/ \; 2>/dev/null || true
                find all-packages -name "*.snupkg" -exec mv {} all-packages/ \; 2>/dev/null || true
                find all-packages -type d -empty -delete 2>/dev/null || true

                echo ""
                echo "Collected packages:"
                ls -la all-packages/

          - task: PublishPipelineArtifact@1
            displayName: Upload combined artifact
            inputs:
              targetPath: $(Build.SourcesDirectory)/all-packages
              artifact: all-nuget-packages
              publishLocation: pipeline
