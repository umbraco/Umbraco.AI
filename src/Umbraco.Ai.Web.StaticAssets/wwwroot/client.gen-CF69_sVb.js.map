{"version":3,"file":"client.gen-CF69_sVb.js","sources":["../Client/src/api/core/bodySerializer.gen.ts","../Client/src/api/core/serverSentEvents.gen.ts","../Client/src/api/core/pathSerializer.gen.ts","../Client/src/api/core/utils.gen.ts","../Client/src/api/core/auth.gen.ts","../Client/src/api/client/utils.gen.ts","../Client/src/api/client/client.gen.ts","../Client/src/api/client.gen.ts"],"sourcesContent":["// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n  ArrayStyle,\n  ObjectStyle,\n  SerializerOptions,\n} from './pathSerializer.gen';\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\nexport interface QuerySerializerOptions {\n  allowReserved?: boolean;\n  array?: SerializerOptions<ArrayStyle>;\n  object?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializeFormDataPair = (\n  data: FormData,\n  key: string,\n  value: unknown,\n): void => {\n  if (typeof value === 'string' || value instanceof Blob) {\n    data.append(key, value);\n  } else if (value instanceof Date) {\n    data.append(key, value.toISOString());\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nconst serializeUrlSearchParamsPair = (\n  data: URLSearchParams,\n  key: string,\n  value: unknown,\n): void => {\n  if (typeof value === 'string') {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nexport const formDataBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ): FormData => {\n    const data = new FormData();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeFormDataPair(data, key, v));\n      } else {\n        serializeFormDataPair(data, key, value);\n      }\n    });\n\n    return data;\n  },\n};\n\nexport const jsonBodySerializer = {\n  bodySerializer: <T>(body: T): string =>\n    JSON.stringify(body, (_key, value) =>\n      typeof value === 'bigint' ? value.toString() : value,\n    ),\n};\n\nexport const urlSearchParamsBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ): string => {\n    const data = new URLSearchParams();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n      } else {\n        serializeUrlSearchParamsPair(data, key, value);\n      }\n    });\n\n    return data.toString();\n  },\n};\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { Config } from './types.gen';\r\n\r\nexport type ServerSentEventsOptions<TData = unknown> = Omit<\r\n  RequestInit,\r\n  'method'\r\n> &\r\n  Pick<Config, 'method' | 'responseTransformer' | 'responseValidator'> & {\r\n    /**\r\n     * Fetch API implementation. You can use this option to provide a custom\r\n     * fetch instance.\r\n     *\r\n     * @default globalThis.fetch\r\n     */\r\n    fetch?: typeof fetch;\r\n    /**\r\n     * Implementing clients can call request interceptors inside this hook.\r\n     */\r\n    onRequest?: (url: string, init: RequestInit) => Promise<Request>;\r\n    /**\r\n     * Callback invoked when a network or parsing error occurs during streaming.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @param error The error that occurred.\r\n     */\r\n    onSseError?: (error: unknown) => void;\r\n    /**\r\n     * Callback invoked when an event is streamed from the server.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @param event Event streamed from the server.\r\n     * @returns Nothing (void).\r\n     */\r\n    onSseEvent?: (event: StreamEvent<TData>) => void;\r\n    serializedBody?: RequestInit['body'];\r\n    /**\r\n     * Default retry delay in milliseconds.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @default 3000\r\n     */\r\n    sseDefaultRetryDelay?: number;\r\n    /**\r\n     * Maximum number of retry attempts before giving up.\r\n     */\r\n    sseMaxRetryAttempts?: number;\r\n    /**\r\n     * Maximum retry delay in milliseconds.\r\n     *\r\n     * Applies only when exponential backoff is used.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @default 30000\r\n     */\r\n    sseMaxRetryDelay?: number;\r\n    /**\r\n     * Optional sleep function for retry backoff.\r\n     *\r\n     * Defaults to using `setTimeout`.\r\n     */\r\n    sseSleepFn?: (ms: number) => Promise<void>;\r\n    url: string;\r\n  };\r\n\r\nexport interface StreamEvent<TData = unknown> {\r\n  data: TData;\r\n  event?: string;\r\n  id?: string;\r\n  retry?: number;\r\n}\r\n\r\nexport type ServerSentEventsResult<\r\n  TData = unknown,\r\n  TReturn = void,\r\n  TNext = unknown,\r\n> = {\r\n  stream: AsyncGenerator<\r\n    TData extends Record<string, unknown> ? TData[keyof TData] : TData,\r\n    TReturn,\r\n    TNext\r\n  >;\r\n};\r\n\r\nexport const createSseClient = <TData = unknown>({\r\n  onRequest,\r\n  onSseError,\r\n  onSseEvent,\r\n  responseTransformer,\r\n  responseValidator,\r\n  sseDefaultRetryDelay,\r\n  sseMaxRetryAttempts,\r\n  sseMaxRetryDelay,\r\n  sseSleepFn,\r\n  url,\r\n  ...options\r\n}: ServerSentEventsOptions): ServerSentEventsResult<TData> => {\r\n  let lastEventId: string | undefined;\r\n\r\n  const sleep =\r\n    sseSleepFn ??\r\n    ((ms: number) => new Promise((resolve) => setTimeout(resolve, ms)));\r\n\r\n  const createStream = async function* () {\r\n    let retryDelay: number = sseDefaultRetryDelay ?? 3000;\r\n    let attempt = 0;\r\n    const signal = options.signal ?? new AbortController().signal;\r\n\r\n    while (true) {\r\n      if (signal.aborted) break;\r\n\r\n      attempt++;\r\n\r\n      const headers =\r\n        options.headers instanceof Headers\r\n          ? options.headers\r\n          : new Headers(options.headers as Record<string, string> | undefined);\r\n\r\n      if (lastEventId !== undefined) {\r\n        headers.set('Last-Event-ID', lastEventId);\r\n      }\r\n\r\n      try {\r\n        const requestInit: RequestInit = {\r\n          redirect: 'follow',\r\n          ...options,\r\n          body: options.serializedBody,\r\n          headers,\r\n          signal,\r\n        };\r\n        let request = new Request(url, requestInit);\r\n        if (onRequest) {\r\n          request = await onRequest(url, requestInit);\r\n        }\r\n        // fetch must be assigned here, otherwise it would throw the error:\r\n        // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\r\n        const _fetch = options.fetch ?? globalThis.fetch;\r\n        const response = await _fetch(request);\r\n\r\n        if (!response.ok)\r\n          throw new Error(\r\n            `SSE failed: ${response.status} ${response.statusText}`,\r\n          );\r\n\r\n        if (!response.body) throw new Error('No body in SSE response');\r\n\r\n        const reader = response.body\r\n          .pipeThrough(new TextDecoderStream())\r\n          .getReader();\r\n\r\n        let buffer = '';\r\n\r\n        const abortHandler = () => {\r\n          try {\r\n            reader.cancel();\r\n          } catch {\r\n            // noop\r\n          }\r\n        };\r\n\r\n        signal.addEventListener('abort', abortHandler);\r\n\r\n        try {\r\n          while (true) {\r\n            const { done, value } = await reader.read();\r\n            if (done) break;\r\n            buffer += value;\r\n\r\n            const chunks = buffer.split('\\n\\n');\r\n            buffer = chunks.pop() ?? '';\r\n\r\n            for (const chunk of chunks) {\r\n              const lines = chunk.split('\\n');\r\n              const dataLines: Array<string> = [];\r\n              let eventName: string | undefined;\r\n\r\n              for (const line of lines) {\r\n                if (line.startsWith('data:')) {\r\n                  dataLines.push(line.replace(/^data:\\s*/, ''));\r\n                } else if (line.startsWith('event:')) {\r\n                  eventName = line.replace(/^event:\\s*/, '');\r\n                } else if (line.startsWith('id:')) {\r\n                  lastEventId = line.replace(/^id:\\s*/, '');\r\n                } else if (line.startsWith('retry:')) {\r\n                  const parsed = Number.parseInt(\r\n                    line.replace(/^retry:\\s*/, ''),\r\n                    10,\r\n                  );\r\n                  if (!Number.isNaN(parsed)) {\r\n                    retryDelay = parsed;\r\n                  }\r\n                }\r\n              }\r\n\r\n              let data: unknown;\r\n              let parsedJson = false;\r\n\r\n              if (dataLines.length) {\r\n                const rawData = dataLines.join('\\n');\r\n                try {\r\n                  data = JSON.parse(rawData);\r\n                  parsedJson = true;\r\n                } catch {\r\n                  data = rawData;\r\n                }\r\n              }\r\n\r\n              if (parsedJson) {\r\n                if (responseValidator) {\r\n                  await responseValidator(data);\r\n                }\r\n\r\n                if (responseTransformer) {\r\n                  data = await responseTransformer(data);\r\n                }\r\n              }\r\n\r\n              onSseEvent?.({\r\n                data,\r\n                event: eventName,\r\n                id: lastEventId,\r\n                retry: retryDelay,\r\n              });\r\n\r\n              if (dataLines.length) {\r\n                yield data as any;\r\n              }\r\n            }\r\n          }\r\n        } finally {\r\n          signal.removeEventListener('abort', abortHandler);\r\n          reader.releaseLock();\r\n        }\r\n\r\n        break; // exit loop on normal completion\r\n      } catch (error) {\r\n        // connection failed or aborted; retry after delay\r\n        onSseError?.(error);\r\n\r\n        if (\r\n          sseMaxRetryAttempts !== undefined &&\r\n          attempt >= sseMaxRetryAttempts\r\n        ) {\r\n          break; // stop after firing error\r\n        }\r\n\r\n        // exponential backoff: double retry each attempt, cap at 30s\r\n        const backoff = Math.min(\r\n          retryDelay * 2 ** (attempt - 1),\r\n          sseMaxRetryDelay ?? 30000,\r\n        );\r\n        await sleep(backoff);\r\n      }\r\n    }\r\n  };\r\n\r\n  const stream = createStream();\r\n\r\n  return { stream };\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\n\ninterface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n  valueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n  valueOnly?: boolean;\n}) => {\n  if (value instanceof Date) {\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { BodySerializer, QuerySerializer } from './bodySerializer.gen';\r\nimport {\r\n  type ArraySeparatorStyle,\r\n  serializeArrayParam,\r\n  serializeObjectParam,\r\n  serializePrimitiveParam,\r\n} from './pathSerializer.gen';\r\n\r\nexport interface PathSerializer {\r\n  path: Record<string, unknown>;\r\n  url: string;\r\n}\r\n\r\nexport const PATH_PARAM_RE = /\\{[^{}]+\\}/g;\r\n\r\nexport const defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\r\n  let url = _url;\r\n  const matches = _url.match(PATH_PARAM_RE);\r\n  if (matches) {\r\n    for (const match of matches) {\r\n      let explode = false;\r\n      let name = match.substring(1, match.length - 1);\r\n      let style: ArraySeparatorStyle = 'simple';\r\n\r\n      if (name.endsWith('*')) {\r\n        explode = true;\r\n        name = name.substring(0, name.length - 1);\r\n      }\r\n\r\n      if (name.startsWith('.')) {\r\n        name = name.substring(1);\r\n        style = 'label';\r\n      } else if (name.startsWith(';')) {\r\n        name = name.substring(1);\r\n        style = 'matrix';\r\n      }\r\n\r\n      const value = path[name];\r\n\r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n\r\n      if (Array.isArray(value)) {\r\n        url = url.replace(\r\n          match,\r\n          serializeArrayParam({ explode, name, style, value }),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      if (typeof value === 'object') {\r\n        url = url.replace(\r\n          match,\r\n          serializeObjectParam({\r\n            explode,\r\n            name,\r\n            style,\r\n            value: value as Record<string, unknown>,\r\n            valueOnly: true,\r\n          }),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      if (style === 'matrix') {\r\n        url = url.replace(\r\n          match,\r\n          `;${serializePrimitiveParam({\r\n            name,\r\n            value: value as string,\r\n          })}`,\r\n        );\r\n        continue;\r\n      }\r\n\r\n      const replaceValue = encodeURIComponent(\r\n        style === 'label' ? `.${value as string}` : (value as string),\r\n      );\r\n      url = url.replace(match, replaceValue);\r\n    }\r\n  }\r\n  return url;\r\n};\r\n\r\nexport const getUrl = ({\r\n  baseUrl,\r\n  path,\r\n  query,\r\n  querySerializer,\r\n  url: _url,\r\n}: {\r\n  baseUrl?: string;\r\n  path?: Record<string, unknown>;\r\n  query?: Record<string, unknown>;\r\n  querySerializer: QuerySerializer;\r\n  url: string;\r\n}) => {\r\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\r\n  let url = (baseUrl ?? '') + pathUrl;\r\n  if (path) {\r\n    url = defaultPathSerializer({ path, url });\r\n  }\r\n  let search = query ? querySerializer(query) : '';\r\n  if (search.startsWith('?')) {\r\n    search = search.substring(1);\r\n  }\r\n  if (search) {\r\n    url += `?${search}`;\r\n  }\r\n  return url;\r\n};\r\n\r\nexport function getValidRequestBody(options: {\r\n  body?: unknown;\r\n  bodySerializer?: BodySerializer | null;\r\n  serializedBody?: unknown;\r\n}) {\r\n  const hasBody = options.body !== undefined;\r\n  const isSerializedBody = hasBody && options.bodySerializer;\r\n\r\n  if (isSerializedBody) {\r\n    if ('serializedBody' in options) {\r\n      const hasSerializedBody =\r\n        options.serializedBody !== undefined && options.serializedBody !== '';\r\n\r\n      return hasSerializedBody ? options.serializedBody : null;\r\n    }\r\n\r\n    // not all clients implement a serializedBody property (i.e. client-axios)\r\n    return options.body !== '' ? options.body : null;\r\n  }\r\n\r\n  // plain/text body\r\n  if (hasBody) {\r\n    return options.body;\r\n  }\r\n\r\n  // no body was provided\r\n  return undefined;\r\n}\r\n","// This file is auto-generated by @hey-api/openapi-ts\n\nexport type AuthToken = string | undefined;\n\nexport interface Auth {\n  /**\n   * Which part of the request do we use to send the auth?\n   *\n   * @default 'header'\n   */\n  in?: 'header' | 'query' | 'cookie';\n  /**\n   * Header or query parameter name.\n   *\n   * @default 'Authorization'\n   */\n  name?: string;\n  scheme?: 'basic' | 'bearer';\n  type: 'apiKey' | 'http';\n}\n\nexport const getAuthToken = async (\n  auth: Auth,\n  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\n): Promise<string | undefined> => {\n  const token =\n    typeof callback === 'function' ? await callback(auth) : callback;\n\n  if (!token) {\n    return;\n  }\n\n  if (auth.scheme === 'bearer') {\n    return `Bearer ${token}`;\n  }\n\n  if (auth.scheme === 'basic') {\n    return `Basic ${btoa(token)}`;\n  }\n\n  return token;\n};\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { getAuthToken } from '../core/auth.gen';\r\nimport type { QuerySerializerOptions } from '../core/bodySerializer.gen';\r\nimport { jsonBodySerializer } from '../core/bodySerializer.gen';\r\nimport {\r\n  serializeArrayParam,\r\n  serializeObjectParam,\r\n  serializePrimitiveParam,\r\n} from '../core/pathSerializer.gen';\r\nimport { getUrl } from '../core/utils.gen';\r\nimport type { Client, ClientOptions, Config, RequestOptions } from './types.gen';\r\n\r\nexport const createQuerySerializer = <T = unknown>({\r\n  allowReserved,\r\n  array,\r\n  object,\r\n}: QuerySerializerOptions = {}) => {\r\n  const querySerializer = (queryParams: T) => {\r\n    const search: string[] = [];\r\n    if (queryParams && typeof queryParams === 'object') {\r\n      for (const name in queryParams) {\r\n        const value = queryParams[name];\r\n\r\n        if (value === undefined || value === null) {\r\n          continue;\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n          const serializedArray = serializeArrayParam({\r\n            allowReserved,\r\n            explode: true,\r\n            name,\r\n            style: 'form',\r\n            value,\r\n            ...array,\r\n          });\r\n          if (serializedArray) search.push(serializedArray);\r\n        } else if (typeof value === 'object') {\r\n          const serializedObject = serializeObjectParam({\r\n            allowReserved,\r\n            explode: true,\r\n            name,\r\n            style: 'deepObject',\r\n            value: value as Record<string, unknown>,\r\n            ...object,\r\n          });\r\n          if (serializedObject) search.push(serializedObject);\r\n        } else {\r\n          const serializedPrimitive = serializePrimitiveParam({\r\n            allowReserved,\r\n            name,\r\n            value: value as string,\r\n          });\r\n          if (serializedPrimitive) search.push(serializedPrimitive);\r\n        }\r\n      }\r\n    }\r\n    return search.join('&');\r\n  };\r\n  return querySerializer;\r\n};\r\n\r\n/**\r\n * Infers parseAs value from provided Content-Type header.\r\n */\r\nexport const getParseAs = (\r\n  contentType: string | null,\r\n): Exclude<Config['parseAs'], 'auto'> => {\r\n  if (!contentType) {\r\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\r\n    // which is effectively the same as the 'stream' option.\r\n    return 'stream';\r\n  }\r\n\r\n  const cleanContent = contentType.split(';')[0]?.trim();\r\n\r\n  if (!cleanContent) {\r\n    return;\r\n  }\r\n\r\n  if (\r\n    cleanContent.startsWith('application/json') ||\r\n    cleanContent.endsWith('+json')\r\n  ) {\r\n    return 'json';\r\n  }\r\n\r\n  if (cleanContent === 'multipart/form-data') {\r\n    return 'formData';\r\n  }\r\n\r\n  if (\r\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\r\n      cleanContent.startsWith(type),\r\n    )\r\n  ) {\r\n    return 'blob';\r\n  }\r\n\r\n  if (cleanContent.startsWith('text/')) {\r\n    return 'text';\r\n  }\r\n\r\n  return;\r\n};\r\n\r\nconst checkForExistence = (\r\n  options: Pick<RequestOptions, 'auth' | 'query'> & {\r\n    headers: Headers;\r\n  },\r\n  name?: string,\r\n): boolean => {\r\n  if (!name) {\r\n    return false;\r\n  }\r\n  if (\r\n    options.headers.has(name) ||\r\n    options.query?.[name] ||\r\n    options.headers.get('Cookie')?.includes(`${name}=`)\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const setAuthParams = async ({\r\n  security,\r\n  ...options\r\n}: Pick<Required<RequestOptions>, 'security'> &\r\n  Pick<RequestOptions, 'auth' | 'query'> & {\r\n    headers: Headers;\r\n  }) => {\r\n  for (const auth of security) {\r\n    if (checkForExistence(options, auth.name)) {\r\n      continue;\r\n    }\r\n\r\n    const token = await getAuthToken(auth, options.auth);\r\n\r\n    if (!token) {\r\n      continue;\r\n    }\r\n\r\n    const name = auth.name ?? 'Authorization';\r\n\r\n    switch (auth.in) {\r\n      case 'query':\r\n        if (!options.query) {\r\n          options.query = {};\r\n        }\r\n        options.query[name] = token;\r\n        break;\r\n      case 'cookie':\r\n        options.headers.append('Cookie', `${name}=${token}`);\r\n        break;\r\n      case 'header':\r\n      default:\r\n        options.headers.set(name, token);\r\n        break;\r\n    }\r\n  }\r\n};\r\n\r\nexport const buildUrl: Client['buildUrl'] = (options) =>\r\n  getUrl({\r\n    baseUrl: options.baseUrl as string,\r\n    path: options.path,\r\n    query: options.query,\r\n    querySerializer:\r\n      typeof options.querySerializer === 'function'\r\n        ? options.querySerializer\r\n        : createQuerySerializer(options.querySerializer),\r\n    url: options.url,\r\n  });\r\n\r\nexport const mergeConfigs = (a: Config, b: Config): Config => {\r\n  const config = { ...a, ...b };\r\n  if (config.baseUrl?.endsWith('/')) {\r\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\r\n  }\r\n  config.headers = mergeHeaders(a.headers, b.headers);\r\n  return config;\r\n};\r\n\r\nconst headersEntries = (headers: Headers): Array<[string, string]> => {\r\n  const entries: Array<[string, string]> = [];\r\n  headers.forEach((value, key) => {\r\n    entries.push([key, value]);\r\n  });\r\n  return entries;\r\n};\r\n\r\nexport const mergeHeaders = (\r\n  ...headers: Array<Required<Config>['headers'] | undefined>\r\n): Headers => {\r\n  const mergedHeaders = new Headers();\r\n  for (const header of headers) {\r\n    if (!header) {\r\n      continue;\r\n    }\r\n\r\n    const iterator =\r\n      header instanceof Headers\r\n        ? headersEntries(header)\r\n        : Object.entries(header);\r\n\r\n    for (const [key, value] of iterator) {\r\n      if (value === null) {\r\n        mergedHeaders.delete(key);\r\n      } else if (Array.isArray(value)) {\r\n        for (const v of value) {\r\n          mergedHeaders.append(key, v as string);\r\n        }\r\n      } else if (value !== undefined) {\r\n        // assume object headers are meant to be JSON stringified, i.e. their\r\n        // content value in OpenAPI specification is 'application/json'\r\n        mergedHeaders.set(\r\n          key,\r\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return mergedHeaders;\r\n};\r\n\r\ntype ErrInterceptor<Err, Res, Req, Options> = (\r\n  error: Err,\r\n  response: Res,\r\n  request: Req,\r\n  options: Options,\r\n) => Err | Promise<Err>;\r\n\r\ntype ReqInterceptor<Req, Options> = (\r\n  request: Req,\r\n  options: Options,\r\n) => Req | Promise<Req>;\r\n\r\ntype ResInterceptor<Res, Req, Options> = (\r\n  response: Res,\r\n  request: Req,\r\n  options: Options,\r\n) => Res | Promise<Res>;\r\n\r\nclass Interceptors<Interceptor> {\r\n  fns: Array<Interceptor | null> = [];\r\n\r\n  clear(): void {\r\n    this.fns = [];\r\n  }\r\n\r\n  eject(id: number | Interceptor): void {\r\n    const index = this.getInterceptorIndex(id);\r\n    if (this.fns[index]) {\r\n      this.fns[index] = null;\r\n    }\r\n  }\r\n\r\n  exists(id: number | Interceptor): boolean {\r\n    const index = this.getInterceptorIndex(id);\r\n    return Boolean(this.fns[index]);\r\n  }\r\n\r\n  getInterceptorIndex(id: number | Interceptor): number {\r\n    if (typeof id === 'number') {\r\n      return this.fns[id] ? id : -1;\r\n    }\r\n    return this.fns.indexOf(id);\r\n  }\r\n\r\n  update(\r\n    id: number | Interceptor,\r\n    fn: Interceptor,\r\n  ): number | Interceptor | false {\r\n    const index = this.getInterceptorIndex(id);\r\n    if (this.fns[index]) {\r\n      this.fns[index] = fn;\r\n      return id;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  use(fn: Interceptor): number {\r\n    this.fns.push(fn);\r\n    return this.fns.length - 1;\r\n  }\r\n}\r\n\r\nexport interface Middleware<Req, Res, Err, Options> {\r\n  error: Interceptors<ErrInterceptor<Err, Res, Req, Options>>;\r\n  request: Interceptors<ReqInterceptor<Req, Options>>;\r\n  response: Interceptors<ResInterceptor<Res, Req, Options>>;\r\n}\r\n\r\nexport const createInterceptors = <Req, Res, Err, Options>(): Middleware<\r\n  Req,\r\n  Res,\r\n  Err,\r\n  Options\r\n> => ({\r\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\r\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\r\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\r\n});\r\n\r\nconst defaultQuerySerializer = createQuerySerializer({\r\n  allowReserved: false,\r\n  array: {\r\n    explode: true,\r\n    style: 'form',\r\n  },\r\n  object: {\r\n    explode: true,\r\n    style: 'deepObject',\r\n  },\r\n});\r\n\r\nconst defaultHeaders = {\r\n  'Content-Type': 'application/json',\r\n};\r\n\r\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\r\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\r\n): Config<Omit<ClientOptions, keyof T> & T> => ({\r\n  ...jsonBodySerializer,\r\n  headers: defaultHeaders,\r\n  parseAs: 'auto',\r\n  querySerializer: defaultQuerySerializer,\r\n  ...override,\r\n});\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { createSseClient } from '../core/serverSentEvents.gen';\r\nimport type { HttpMethod } from '../core/types.gen';\r\nimport { getValidRequestBody } from '../core/utils.gen';\r\nimport type {\r\n  Client,\r\n  Config,\r\n  RequestOptions,\r\n  ResolvedRequestOptions,\r\n} from './types.gen';\r\nimport {\r\n  buildUrl,\r\n  createConfig,\r\n  createInterceptors,\r\n  getParseAs,\r\n  mergeConfigs,\r\n  mergeHeaders,\r\n  setAuthParams,\r\n} from './utils.gen';\r\n\r\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\r\n  body?: any;\r\n  headers: ReturnType<typeof mergeHeaders>;\r\n};\r\n\r\nexport const createClient = (config: Config = {}): Client => {\r\n  let _config = mergeConfigs(createConfig(), config);\r\n\r\n  const getConfig = (): Config => ({ ..._config });\r\n\r\n  const setConfig = (config: Config): Config => {\r\n    _config = mergeConfigs(_config, config);\r\n    return getConfig();\r\n  };\r\n\r\n  const interceptors = createInterceptors<\r\n    Request,\r\n    Response,\r\n    unknown,\r\n    ResolvedRequestOptions\r\n  >();\r\n\r\n  const beforeRequest = async (options: RequestOptions) => {\r\n    const opts = {\r\n      ..._config,\r\n      ...options,\r\n      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\r\n      headers: mergeHeaders(_config.headers, options.headers),\r\n      serializedBody: undefined,\r\n    };\r\n\r\n    if (opts.security) {\r\n      await setAuthParams({\r\n        ...opts,\r\n        security: opts.security,\r\n      });\r\n    }\r\n\r\n    if (opts.requestValidator) {\r\n      await opts.requestValidator(opts);\r\n    }\r\n\r\n    if (opts.body !== undefined && opts.bodySerializer) {\r\n      opts.serializedBody = opts.bodySerializer(opts.body);\r\n    }\r\n\r\n    // remove Content-Type header if body is empty to avoid sending invalid requests\r\n    if (opts.body === undefined || opts.serializedBody === '') {\r\n      opts.headers.delete('Content-Type');\r\n    }\r\n\r\n    const url = buildUrl(opts);\r\n\r\n    return { opts, url };\r\n  };\r\n\r\n  const request: Client['request'] = async (options) => {\r\n    // @ts-expect-error\r\n    const { opts, url } = await beforeRequest(options);\r\n    const requestInit: ReqInit = {\r\n      redirect: 'follow',\r\n      ...opts,\r\n      body: getValidRequestBody(opts),\r\n    };\r\n\r\n    let request = new Request(url, requestInit);\r\n\r\n    for (const fn of interceptors.request.fns) {\r\n      if (fn) {\r\n        request = await fn(request, opts);\r\n      }\r\n    }\r\n\r\n    // fetch must be assigned here, otherwise it would throw the error:\r\n    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\r\n    const _fetch = opts.fetch!;\r\n    let response = await _fetch(request);\r\n\r\n    for (const fn of interceptors.response.fns) {\r\n      if (fn) {\r\n        response = await fn(response, request, opts);\r\n      }\r\n    }\r\n\r\n    const result = {\r\n      request,\r\n      response,\r\n    };\r\n\r\n    if (response.ok) {\r\n      const parseAs =\r\n        (opts.parseAs === 'auto'\r\n          ? getParseAs(response.headers.get('Content-Type'))\r\n          : opts.parseAs) ?? 'json';\r\n\r\n      if (\r\n        response.status === 204 ||\r\n        response.headers.get('Content-Length') === '0'\r\n      ) {\r\n        let emptyData: any;\r\n        switch (parseAs) {\r\n          case 'arrayBuffer':\r\n          case 'blob':\r\n          case 'text':\r\n            emptyData = await response[parseAs]();\r\n            break;\r\n          case 'formData':\r\n            emptyData = new FormData();\r\n            break;\r\n          case 'stream':\r\n            emptyData = response.body;\r\n            break;\r\n          case 'json':\r\n          default:\r\n            emptyData = {};\r\n            break;\r\n        }\r\n        return opts.responseStyle === 'data'\r\n          ? emptyData\r\n          : {\r\n              data: emptyData,\r\n              ...result,\r\n            };\r\n      }\r\n\r\n      let data: any;\r\n      switch (parseAs) {\r\n        case 'arrayBuffer':\r\n        case 'blob':\r\n        case 'formData':\r\n        case 'json':\r\n        case 'text':\r\n          data = await response[parseAs]();\r\n          break;\r\n        case 'stream':\r\n          return opts.responseStyle === 'data'\r\n            ? response.body\r\n            : {\r\n                data: response.body,\r\n                ...result,\r\n              };\r\n      }\r\n\r\n      if (parseAs === 'json') {\r\n        if (opts.responseValidator) {\r\n          await opts.responseValidator(data);\r\n        }\r\n\r\n        if (opts.responseTransformer) {\r\n          data = await opts.responseTransformer(data);\r\n        }\r\n      }\r\n\r\n      return opts.responseStyle === 'data'\r\n        ? data\r\n        : {\r\n            data,\r\n            ...result,\r\n          };\r\n    }\r\n\r\n    const textError = await response.text();\r\n    let jsonError: unknown;\r\n\r\n    try {\r\n      jsonError = JSON.parse(textError);\r\n    } catch {\r\n      // noop\r\n    }\r\n\r\n    const error = jsonError ?? textError;\r\n    let finalError = error;\r\n\r\n    for (const fn of interceptors.error.fns) {\r\n      if (fn) {\r\n        finalError = (await fn(error, response, request, opts)) as string;\r\n      }\r\n    }\r\n\r\n    finalError = finalError || ({} as string);\r\n\r\n    if (opts.throwOnError) {\r\n      throw finalError;\r\n    }\r\n\r\n    // TODO: we probably want to return error and improve types\r\n    return opts.responseStyle === 'data'\r\n      ? undefined\r\n      : {\r\n          error: finalError,\r\n          ...result,\r\n        };\r\n  };\r\n\r\n  const makeMethodFn =\r\n    (method: Uppercase<HttpMethod>) => (options: RequestOptions) =>\r\n      request({ ...options, method });\r\n\r\n  const makeSseFn =\r\n    (method: Uppercase<HttpMethod>) => async (options: RequestOptions) => {\r\n      const { opts, url } = await beforeRequest(options);\r\n      return createSseClient({\r\n        ...opts,\r\n        body: opts.body as BodyInit | null | undefined,\r\n        headers: opts.headers as unknown as Record<string, string>,\r\n        method,\r\n        onRequest: async (url, init) => {\r\n          let request = new Request(url, init);\r\n          for (const fn of interceptors.request.fns) {\r\n            if (fn) {\r\n              request = await fn(request, opts);\r\n            }\r\n          }\r\n          return request;\r\n        },\r\n        url,\r\n      });\r\n    };\r\n\r\n  return {\r\n    buildUrl,\r\n    connect: makeMethodFn('CONNECT'),\r\n    delete: makeMethodFn('DELETE'),\r\n    get: makeMethodFn('GET'),\r\n    getConfig,\r\n    head: makeMethodFn('HEAD'),\r\n    interceptors,\r\n    options: makeMethodFn('OPTIONS'),\r\n    patch: makeMethodFn('PATCH'),\r\n    post: makeMethodFn('POST'),\r\n    put: makeMethodFn('PUT'),\r\n    request,\r\n    setConfig,\r\n    sse: {\r\n      connect: makeSseFn('CONNECT'),\r\n      delete: makeSseFn('DELETE'),\r\n      get: makeSseFn('GET'),\r\n      head: makeSseFn('HEAD'),\r\n      options: makeSseFn('OPTIONS'),\r\n      patch: makeSseFn('PATCH'),\r\n      post: makeSseFn('POST'),\r\n      put: makeSseFn('PUT'),\r\n      trace: makeSseFn('TRACE'),\r\n    },\r\n    trace: makeMethodFn('TRACE'),\r\n  } as Client;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { type ClientOptions, type Config, createClient, createConfig } from './client';\r\nimport type { ClientOptions as ClientOptions2 } from './types.gen';\r\n\r\n/**\r\n * The `createClientConfig()` function will be called on client initialization\r\n * and the returned object will become the client's initial configuration.\r\n *\r\n * You may want to initialize your client this way instead of calling\r\n * `setConfig()`. This is useful for example if you're using Next.js\r\n * to ensure your client always has the correct values.\r\n */\r\nexport type CreateClientConfig<T extends ClientOptions = ClientOptions2> = (override?: Config<ClientOptions & T>) => Config<Required<ClientOptions> & T>;\r\n\r\nexport const client = createClient(createConfig<ClientOptions2>({\r\n    baseUrl: 'https://localhost:44363'\r\n}));\r\n"],"names":["jsonBodySerializer","body","_key","value","createSseClient","onRequest","onSseError","onSseEvent","responseTransformer","responseValidator","sseDefaultRetryDelay","sseMaxRetryAttempts","sseMaxRetryDelay","sseSleepFn","url","options","lastEventId","sleep","ms","resolve","retryDelay","attempt","signal","headers","requestInit","request","response","reader","buffer","abortHandler","done","chunks","chunk","lines","dataLines","eventName","line","parsed","data","parsedJson","rawData","error","backoff","separatorArrayExplode","style","separatorArrayNoExplode","separatorObjectExplode","serializeArrayParam","allowReserved","explode","name","joinedValues","v","separator","serializePrimitiveParam","serializeObjectParam","valueOnly","values","key","PATH_PARAM_RE","defaultPathSerializer","path","_url","matches","match","replaceValue","getUrl","baseUrl","query","querySerializer","pathUrl","search","getValidRequestBody","hasBody","getAuthToken","auth","callback","token","createQuerySerializer","array","object","queryParams","serializedArray","serializedObject","serializedPrimitive","getParseAs","contentType","cleanContent","type","checkForExistence","setAuthParams","security","buildUrl","mergeConfigs","a","b","config","mergeHeaders","headersEntries","entries","mergedHeaders","header","iterator","Interceptors","id","index","fn","createInterceptors","defaultQuerySerializer","defaultHeaders","createConfig","override","createClient","_config","getConfig","setConfig","interceptors","beforeRequest","opts","_fetch","result","parseAs","emptyData","textError","jsonError","finalError","makeMethodFn","method","makeSseFn","init","client"],"mappings":"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"}