{"version":3,"file":"client.gen-Ce7o8kG8.js","sources":["../Client/src/api/core/bodySerializer.gen.ts","../Client/src/api/core/serverSentEvents.gen.ts","../Client/src/api/core/auth.gen.ts","../Client/src/api/core/pathSerializer.gen.ts","../Client/src/api/core/utils.gen.ts","../Client/src/api/client/utils.gen.ts","../Client/src/api/client/client.gen.ts","../Client/src/api/client.gen.ts"],"sourcesContent":["// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n  ArrayStyle,\n  ObjectStyle,\n  SerializerOptions,\n} from './pathSerializer.gen';\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\nexport interface QuerySerializerOptions {\n  allowReserved?: boolean;\n  array?: SerializerOptions<ArrayStyle>;\n  object?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializeFormDataPair = (\n  data: FormData,\n  key: string,\n  value: unknown,\n): void => {\n  if (typeof value === 'string' || value instanceof Blob) {\n    data.append(key, value);\n  } else if (value instanceof Date) {\n    data.append(key, value.toISOString());\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nconst serializeUrlSearchParamsPair = (\n  data: URLSearchParams,\n  key: string,\n  value: unknown,\n): void => {\n  if (typeof value === 'string') {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nexport const formDataBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ): FormData => {\n    const data = new FormData();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeFormDataPair(data, key, v));\n      } else {\n        serializeFormDataPair(data, key, value);\n      }\n    });\n\n    return data;\n  },\n};\n\nexport const jsonBodySerializer = {\n  bodySerializer: <T>(body: T): string =>\n    JSON.stringify(body, (_key, value) =>\n      typeof value === 'bigint' ? value.toString() : value,\n    ),\n};\n\nexport const urlSearchParamsBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ): string => {\n    const data = new URLSearchParams();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n      } else {\n        serializeUrlSearchParamsPair(data, key, value);\n      }\n    });\n\n    return data.toString();\n  },\n};\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { Config } from './types.gen';\r\n\r\nexport type ServerSentEventsOptions<TData = unknown> = Omit<\r\n  RequestInit,\r\n  'method'\r\n> &\r\n  Pick<Config, 'method' | 'responseTransformer' | 'responseValidator'> & {\r\n    /**\r\n     * Callback invoked when a network or parsing error occurs during streaming.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @param error The error that occurred.\r\n     */\r\n    onSseError?: (error: unknown) => void;\r\n    /**\r\n     * Callback invoked when an event is streamed from the server.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @param event Event streamed from the server.\r\n     * @returns Nothing (void).\r\n     */\r\n    onSseEvent?: (event: StreamEvent<TData>) => void;\r\n    /**\r\n     * Default retry delay in milliseconds.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @default 3000\r\n     */\r\n    sseDefaultRetryDelay?: number;\r\n    /**\r\n     * Maximum number of retry attempts before giving up.\r\n     */\r\n    sseMaxRetryAttempts?: number;\r\n    /**\r\n     * Maximum retry delay in milliseconds.\r\n     *\r\n     * Applies only when exponential backoff is used.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @default 30000\r\n     */\r\n    sseMaxRetryDelay?: number;\r\n    /**\r\n     * Optional sleep function for retry backoff.\r\n     *\r\n     * Defaults to using `setTimeout`.\r\n     */\r\n    sseSleepFn?: (ms: number) => Promise<void>;\r\n    url: string;\r\n  };\r\n\r\nexport interface StreamEvent<TData = unknown> {\r\n  data: TData;\r\n  event?: string;\r\n  id?: string;\r\n  retry?: number;\r\n}\r\n\r\nexport type ServerSentEventsResult<\r\n  TData = unknown,\r\n  TReturn = void,\r\n  TNext = unknown,\r\n> = {\r\n  stream: AsyncGenerator<\r\n    TData extends Record<string, unknown> ? TData[keyof TData] : TData,\r\n    TReturn,\r\n    TNext\r\n  >;\r\n};\r\n\r\nexport const createSseClient = <TData = unknown>({\r\n  onSseError,\r\n  onSseEvent,\r\n  responseTransformer,\r\n  responseValidator,\r\n  sseDefaultRetryDelay,\r\n  sseMaxRetryAttempts,\r\n  sseMaxRetryDelay,\r\n  sseSleepFn,\r\n  url,\r\n  ...options\r\n}: ServerSentEventsOptions): ServerSentEventsResult<TData> => {\r\n  let lastEventId: string | undefined;\r\n\r\n  const sleep =\r\n    sseSleepFn ??\r\n    ((ms: number) => new Promise((resolve) => setTimeout(resolve, ms)));\r\n\r\n  const createStream = async function* () {\r\n    let retryDelay: number = sseDefaultRetryDelay ?? 3000;\r\n    let attempt = 0;\r\n    const signal = options.signal ?? new AbortController().signal;\r\n\r\n    while (true) {\r\n      if (signal.aborted) break;\r\n\r\n      attempt++;\r\n\r\n      const headers =\r\n        options.headers instanceof Headers\r\n          ? options.headers\r\n          : new Headers(options.headers as Record<string, string> | undefined);\r\n\r\n      if (lastEventId !== undefined) {\r\n        headers.set('Last-Event-ID', lastEventId);\r\n      }\r\n\r\n      try {\r\n        const response = await fetch(url, { ...options, headers, signal });\r\n\r\n        if (!response.ok)\r\n          throw new Error(\r\n            `SSE failed: ${response.status} ${response.statusText}`,\r\n          );\r\n\r\n        if (!response.body) throw new Error('No body in SSE response');\r\n\r\n        const reader = response.body\r\n          .pipeThrough(new TextDecoderStream())\r\n          .getReader();\r\n\r\n        let buffer = '';\r\n\r\n        const abortHandler = () => {\r\n          try {\r\n            reader.cancel();\r\n          } catch {\r\n            // noop\r\n          }\r\n        };\r\n\r\n        signal.addEventListener('abort', abortHandler);\r\n\r\n        try {\r\n          while (true) {\r\n            const { done, value } = await reader.read();\r\n            if (done) break;\r\n            buffer += value;\r\n\r\n            const chunks = buffer.split('\\n\\n');\r\n            buffer = chunks.pop() ?? '';\r\n\r\n            for (const chunk of chunks) {\r\n              const lines = chunk.split('\\n');\r\n              const dataLines: Array<string> = [];\r\n              let eventName: string | undefined;\r\n\r\n              for (const line of lines) {\r\n                if (line.startsWith('data:')) {\r\n                  dataLines.push(line.replace(/^data:\\s*/, ''));\r\n                } else if (line.startsWith('event:')) {\r\n                  eventName = line.replace(/^event:\\s*/, '');\r\n                } else if (line.startsWith('id:')) {\r\n                  lastEventId = line.replace(/^id:\\s*/, '');\r\n                } else if (line.startsWith('retry:')) {\r\n                  const parsed = Number.parseInt(\r\n                    line.replace(/^retry:\\s*/, ''),\r\n                    10,\r\n                  );\r\n                  if (!Number.isNaN(parsed)) {\r\n                    retryDelay = parsed;\r\n                  }\r\n                }\r\n              }\r\n\r\n              let data: unknown;\r\n              let parsedJson = false;\r\n\r\n              if (dataLines.length) {\r\n                const rawData = dataLines.join('\\n');\r\n                try {\r\n                  data = JSON.parse(rawData);\r\n                  parsedJson = true;\r\n                } catch {\r\n                  data = rawData;\r\n                }\r\n              }\r\n\r\n              if (parsedJson) {\r\n                if (responseValidator) {\r\n                  await responseValidator(data);\r\n                }\r\n\r\n                if (responseTransformer) {\r\n                  data = await responseTransformer(data);\r\n                }\r\n              }\r\n\r\n              onSseEvent?.({\r\n                data,\r\n                event: eventName,\r\n                id: lastEventId,\r\n                retry: retryDelay,\r\n              });\r\n\r\n              if (dataLines.length) {\r\n                yield data as any;\r\n              }\r\n            }\r\n          }\r\n        } finally {\r\n          signal.removeEventListener('abort', abortHandler);\r\n          reader.releaseLock();\r\n        }\r\n\r\n        break; // exit loop on normal completion\r\n      } catch (error) {\r\n        // connection failed or aborted; retry after delay\r\n        onSseError?.(error);\r\n\r\n        if (\r\n          sseMaxRetryAttempts !== undefined &&\r\n          attempt >= sseMaxRetryAttempts\r\n        ) {\r\n          break; // stop after firing error\r\n        }\r\n\r\n        // exponential backoff: double retry each attempt, cap at 30s\r\n        const backoff = Math.min(\r\n          retryDelay * 2 ** (attempt - 1),\r\n          sseMaxRetryDelay ?? 30000,\r\n        );\r\n        await sleep(backoff);\r\n      }\r\n    }\r\n  };\r\n\r\n  const stream = createStream();\r\n\r\n  return { stream };\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\n\nexport type AuthToken = string | undefined;\n\nexport interface Auth {\n  /**\n   * Which part of the request do we use to send the auth?\n   *\n   * @default 'header'\n   */\n  in?: 'header' | 'query' | 'cookie';\n  /**\n   * Header or query parameter name.\n   *\n   * @default 'Authorization'\n   */\n  name?: string;\n  scheme?: 'basic' | 'bearer';\n  type: 'apiKey' | 'http';\n}\n\nexport const getAuthToken = async (\n  auth: Auth,\n  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\n): Promise<string | undefined> => {\n  const token =\n    typeof callback === 'function' ? await callback(auth) : callback;\n\n  if (!token) {\n    return;\n  }\n\n  if (auth.scheme === 'bearer') {\n    return `Bearer ${token}`;\n  }\n\n  if (auth.scheme === 'basic') {\n    return `Basic ${btoa(token)}`;\n  }\n\n  return token;\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\ninterface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n  valueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n  valueOnly?: boolean;\n}) => {\n  if (value instanceof Date) {\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { QuerySerializer } from './bodySerializer.gen';\r\nimport {\r\n  type ArraySeparatorStyle,\r\n  serializeArrayParam,\r\n  serializeObjectParam,\r\n  serializePrimitiveParam,\r\n} from './pathSerializer.gen';\r\n\r\nexport interface PathSerializer {\r\n  path: Record<string, unknown>;\r\n  url: string;\r\n}\r\n\r\nexport const PATH_PARAM_RE = /\\{[^{}]+\\}/g;\r\n\r\nexport const defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\r\n  let url = _url;\r\n  const matches = _url.match(PATH_PARAM_RE);\r\n  if (matches) {\r\n    for (const match of matches) {\r\n      let explode = false;\r\n      let name = match.substring(1, match.length - 1);\r\n      let style: ArraySeparatorStyle = 'simple';\r\n\r\n      if (name.endsWith('*')) {\r\n        explode = true;\r\n        name = name.substring(0, name.length - 1);\r\n      }\r\n\r\n      if (name.startsWith('.')) {\r\n        name = name.substring(1);\r\n        style = 'label';\r\n      } else if (name.startsWith(';')) {\r\n        name = name.substring(1);\r\n        style = 'matrix';\r\n      }\r\n\r\n      const value = path[name];\r\n\r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n\r\n      if (Array.isArray(value)) {\r\n        url = url.replace(\r\n          match,\r\n          serializeArrayParam({ explode, name, style, value }),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      if (typeof value === 'object') {\r\n        url = url.replace(\r\n          match,\r\n          serializeObjectParam({\r\n            explode,\r\n            name,\r\n            style,\r\n            value: value as Record<string, unknown>,\r\n            valueOnly: true,\r\n          }),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      if (style === 'matrix') {\r\n        url = url.replace(\r\n          match,\r\n          `;${serializePrimitiveParam({\r\n            name,\r\n            value: value as string,\r\n          })}`,\r\n        );\r\n        continue;\r\n      }\r\n\r\n      const replaceValue = encodeURIComponent(\r\n        style === 'label' ? `.${value as string}` : (value as string),\r\n      );\r\n      url = url.replace(match, replaceValue);\r\n    }\r\n  }\r\n  return url;\r\n};\r\n\r\nexport const getUrl = ({\r\n  baseUrl,\r\n  path,\r\n  query,\r\n  querySerializer,\r\n  url: _url,\r\n}: {\r\n  baseUrl?: string;\r\n  path?: Record<string, unknown>;\r\n  query?: Record<string, unknown>;\r\n  querySerializer: QuerySerializer;\r\n  url: string;\r\n}) => {\r\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\r\n  let url = (baseUrl ?? '') + pathUrl;\r\n  if (path) {\r\n    url = defaultPathSerializer({ path, url });\r\n  }\r\n  let search = query ? querySerializer(query) : '';\r\n  if (search.startsWith('?')) {\r\n    search = search.substring(1);\r\n  }\r\n  if (search) {\r\n    url += `?${search}`;\r\n  }\r\n  return url;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { getAuthToken } from '../core/auth.gen';\r\nimport type { QuerySerializerOptions } from '../core/bodySerializer.gen';\r\nimport { jsonBodySerializer } from '../core/bodySerializer.gen';\r\nimport {\r\n  serializeArrayParam,\r\n  serializeObjectParam,\r\n  serializePrimitiveParam,\r\n} from '../core/pathSerializer.gen';\r\nimport { getUrl } from '../core/utils.gen';\r\nimport type { Client, ClientOptions, Config, RequestOptions } from './types.gen';\r\n\r\nexport const createQuerySerializer = <T = unknown>({\r\n  allowReserved,\r\n  array,\r\n  object,\r\n}: QuerySerializerOptions = {}) => {\r\n  const querySerializer = (queryParams: T) => {\r\n    const search: string[] = [];\r\n    if (queryParams && typeof queryParams === 'object') {\r\n      for (const name in queryParams) {\r\n        const value = queryParams[name];\r\n\r\n        if (value === undefined || value === null) {\r\n          continue;\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n          const serializedArray = serializeArrayParam({\r\n            allowReserved,\r\n            explode: true,\r\n            name,\r\n            style: 'form',\r\n            value,\r\n            ...array,\r\n          });\r\n          if (serializedArray) search.push(serializedArray);\r\n        } else if (typeof value === 'object') {\r\n          const serializedObject = serializeObjectParam({\r\n            allowReserved,\r\n            explode: true,\r\n            name,\r\n            style: 'deepObject',\r\n            value: value as Record<string, unknown>,\r\n            ...object,\r\n          });\r\n          if (serializedObject) search.push(serializedObject);\r\n        } else {\r\n          const serializedPrimitive = serializePrimitiveParam({\r\n            allowReserved,\r\n            name,\r\n            value: value as string,\r\n          });\r\n          if (serializedPrimitive) search.push(serializedPrimitive);\r\n        }\r\n      }\r\n    }\r\n    return search.join('&');\r\n  };\r\n  return querySerializer;\r\n};\r\n\r\n/**\r\n * Infers parseAs value from provided Content-Type header.\r\n */\r\nexport const getParseAs = (\r\n  contentType: string | null,\r\n): Exclude<Config['parseAs'], 'auto'> => {\r\n  if (!contentType) {\r\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\r\n    // which is effectively the same as the 'stream' option.\r\n    return 'stream';\r\n  }\r\n\r\n  const cleanContent = contentType.split(';')[0]?.trim();\r\n\r\n  if (!cleanContent) {\r\n    return;\r\n  }\r\n\r\n  if (\r\n    cleanContent.startsWith('application/json') ||\r\n    cleanContent.endsWith('+json')\r\n  ) {\r\n    return 'json';\r\n  }\r\n\r\n  if (cleanContent === 'multipart/form-data') {\r\n    return 'formData';\r\n  }\r\n\r\n  if (\r\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\r\n      cleanContent.startsWith(type),\r\n    )\r\n  ) {\r\n    return 'blob';\r\n  }\r\n\r\n  if (cleanContent.startsWith('text/')) {\r\n    return 'text';\r\n  }\r\n\r\n  return;\r\n};\r\n\r\nconst checkForExistence = (\r\n  options: Pick<RequestOptions, 'auth' | 'query'> & {\r\n    headers: Headers;\r\n  },\r\n  name?: string,\r\n): boolean => {\r\n  if (!name) {\r\n    return false;\r\n  }\r\n  if (\r\n    options.headers.has(name) ||\r\n    options.query?.[name] ||\r\n    options.headers.get('Cookie')?.includes(`${name}=`)\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const setAuthParams = async ({\r\n  security,\r\n  ...options\r\n}: Pick<Required<RequestOptions>, 'security'> &\r\n  Pick<RequestOptions, 'auth' | 'query'> & {\r\n    headers: Headers;\r\n  }) => {\r\n  for (const auth of security) {\r\n    if (checkForExistence(options, auth.name)) {\r\n      continue;\r\n    }\r\n\r\n    const token = await getAuthToken(auth, options.auth);\r\n\r\n    if (!token) {\r\n      continue;\r\n    }\r\n\r\n    const name = auth.name ?? 'Authorization';\r\n\r\n    switch (auth.in) {\r\n      case 'query':\r\n        if (!options.query) {\r\n          options.query = {};\r\n        }\r\n        options.query[name] = token;\r\n        break;\r\n      case 'cookie':\r\n        options.headers.append('Cookie', `${name}=${token}`);\r\n        break;\r\n      case 'header':\r\n      default:\r\n        options.headers.set(name, token);\r\n        break;\r\n    }\r\n  }\r\n};\r\n\r\nexport const buildUrl: Client['buildUrl'] = (options) =>\r\n  getUrl({\r\n    baseUrl: options.baseUrl as string,\r\n    path: options.path,\r\n    query: options.query,\r\n    querySerializer:\r\n      typeof options.querySerializer === 'function'\r\n        ? options.querySerializer\r\n        : createQuerySerializer(options.querySerializer),\r\n    url: options.url,\r\n  });\r\n\r\nexport const mergeConfigs = (a: Config, b: Config): Config => {\r\n  const config = { ...a, ...b };\r\n  if (config.baseUrl?.endsWith('/')) {\r\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\r\n  }\r\n  config.headers = mergeHeaders(a.headers, b.headers);\r\n  return config;\r\n};\r\n\r\nexport const mergeHeaders = (\r\n  ...headers: Array<Required<Config>['headers'] | undefined>\r\n): Headers => {\r\n  const mergedHeaders = new Headers();\r\n  for (const header of headers) {\r\n    if (!header || typeof header !== 'object') {\r\n      continue;\r\n    }\r\n\r\n    const iterator =\r\n      header instanceof Headers ? header.entries() : Object.entries(header);\r\n\r\n    for (const [key, value] of iterator) {\r\n      if (value === null) {\r\n        mergedHeaders.delete(key);\r\n      } else if (Array.isArray(value)) {\r\n        for (const v of value) {\r\n          mergedHeaders.append(key, v as string);\r\n        }\r\n      } else if (value !== undefined) {\r\n        // assume object headers are meant to be JSON stringified, i.e. their\r\n        // content value in OpenAPI specification is 'application/json'\r\n        mergedHeaders.set(\r\n          key,\r\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return mergedHeaders;\r\n};\r\n\r\ntype ErrInterceptor<Err, Res, Req, Options> = (\r\n  error: Err,\r\n  response: Res,\r\n  request: Req,\r\n  options: Options,\r\n) => Err | Promise<Err>;\r\n\r\ntype ReqInterceptor<Req, Options> = (\r\n  request: Req,\r\n  options: Options,\r\n) => Req | Promise<Req>;\r\n\r\ntype ResInterceptor<Res, Req, Options> = (\r\n  response: Res,\r\n  request: Req,\r\n  options: Options,\r\n) => Res | Promise<Res>;\r\n\r\nclass Interceptors<Interceptor> {\r\n  _fns: (Interceptor | null)[];\r\n\r\n  constructor() {\r\n    this._fns = [];\r\n  }\r\n\r\n  clear() {\r\n    this._fns = [];\r\n  }\r\n\r\n  getInterceptorIndex(id: number | Interceptor): number {\r\n    if (typeof id === 'number') {\r\n      return this._fns[id] ? id : -1;\r\n    } else {\r\n      return this._fns.indexOf(id);\r\n    }\r\n  }\r\n  exists(id: number | Interceptor) {\r\n    const index = this.getInterceptorIndex(id);\r\n    return !!this._fns[index];\r\n  }\r\n\r\n  eject(id: number | Interceptor) {\r\n    const index = this.getInterceptorIndex(id);\r\n    if (this._fns[index]) {\r\n      this._fns[index] = null;\r\n    }\r\n  }\r\n\r\n  update(id: number | Interceptor, fn: Interceptor) {\r\n    const index = this.getInterceptorIndex(id);\r\n    if (this._fns[index]) {\r\n      this._fns[index] = fn;\r\n      return id;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  use(fn: Interceptor) {\r\n    this._fns = [...this._fns, fn];\r\n    return this._fns.length - 1;\r\n  }\r\n}\r\n\r\n// `createInterceptors()` response, meant for external use as it does not\r\n// expose internals\r\nexport interface Middleware<Req, Res, Err, Options> {\r\n  error: Pick<\r\n    Interceptors<ErrInterceptor<Err, Res, Req, Options>>,\r\n    'eject' | 'use'\r\n  >;\r\n  request: Pick<Interceptors<ReqInterceptor<Req, Options>>, 'eject' | 'use'>;\r\n  response: Pick<\r\n    Interceptors<ResInterceptor<Res, Req, Options>>,\r\n    'eject' | 'use'\r\n  >;\r\n}\r\n\r\n// do not add `Middleware` as return type so we can use _fns internally\r\nexport const createInterceptors = <Req, Res, Err, Options>() => ({\r\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\r\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\r\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\r\n});\r\n\r\nconst defaultQuerySerializer = createQuerySerializer({\r\n  allowReserved: false,\r\n  array: {\r\n    explode: true,\r\n    style: 'form',\r\n  },\r\n  object: {\r\n    explode: true,\r\n    style: 'deepObject',\r\n  },\r\n});\r\n\r\nconst defaultHeaders = {\r\n  'Content-Type': 'application/json',\r\n};\r\n\r\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\r\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\r\n): Config<Omit<ClientOptions, keyof T> & T> => ({\r\n  ...jsonBodySerializer,\r\n  headers: defaultHeaders,\r\n  parseAs: 'auto',\r\n  querySerializer: defaultQuerySerializer,\r\n  ...override,\r\n});\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { createSseClient } from '../core/serverSentEvents.gen';\r\nimport type { HttpMethod } from '../core/types.gen';\r\nimport type {\r\n  Client,\r\n  Config,\r\n  RequestOptions,\r\n  ResolvedRequestOptions,\r\n} from './types.gen';\r\nimport {\r\n  buildUrl,\r\n  createConfig,\r\n  createInterceptors,\r\n  getParseAs,\r\n  mergeConfigs,\r\n  mergeHeaders,\r\n  setAuthParams,\r\n} from './utils.gen';\r\n\r\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\r\n  body?: any;\r\n  headers: ReturnType<typeof mergeHeaders>;\r\n};\r\n\r\nexport const createClient = (config: Config = {}): Client => {\r\n  let _config = mergeConfigs(createConfig(), config);\r\n\r\n  const getConfig = (): Config => ({ ..._config });\r\n\r\n  const setConfig = (config: Config): Config => {\r\n    _config = mergeConfigs(_config, config);\r\n    return getConfig();\r\n  };\r\n\r\n  const interceptors = createInterceptors<\r\n    Request,\r\n    Response,\r\n    unknown,\r\n    ResolvedRequestOptions\r\n  >();\r\n\r\n  const beforeRequest = async (options: RequestOptions) => {\r\n    const opts = {\r\n      ..._config,\r\n      ...options,\r\n      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\r\n      headers: mergeHeaders(_config.headers, options.headers),\r\n      serializedBody: undefined,\r\n    };\r\n\r\n    if (opts.security) {\r\n      await setAuthParams({\r\n        ...opts,\r\n        security: opts.security,\r\n      });\r\n    }\r\n\r\n    if (opts.requestValidator) {\r\n      await opts.requestValidator(opts);\r\n    }\r\n\r\n    if (opts.body && opts.bodySerializer) {\r\n      opts.serializedBody = opts.bodySerializer(opts.body);\r\n    }\r\n\r\n    // remove Content-Type header if body is empty to avoid sending invalid requests\r\n    if (opts.serializedBody === undefined || opts.serializedBody === '') {\r\n      opts.headers.delete('Content-Type');\r\n    }\r\n\r\n    const url = buildUrl(opts);\r\n\r\n    return { opts, url };\r\n  };\r\n\r\n  const request: Client['request'] = async (options) => {\r\n    // @ts-expect-error\r\n    const { opts, url } = await beforeRequest(options);\r\n    const requestInit: ReqInit = {\r\n      redirect: 'follow',\r\n      ...opts,\r\n      body: opts.serializedBody,\r\n    };\r\n\r\n    let request = new Request(url, requestInit);\r\n\r\n    for (const fn of interceptors.request._fns) {\r\n      if (fn) {\r\n        request = await fn(request, opts);\r\n      }\r\n    }\r\n\r\n    // fetch must be assigned here, otherwise it would throw the error:\r\n    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\r\n    const _fetch = opts.fetch!;\r\n    let response = await _fetch(request);\r\n\r\n    for (const fn of interceptors.response._fns) {\r\n      if (fn) {\r\n        response = await fn(response, request, opts);\r\n      }\r\n    }\r\n\r\n    const result = {\r\n      request,\r\n      response,\r\n    };\r\n\r\n    if (response.ok) {\r\n      if (\r\n        response.status === 204 ||\r\n        response.headers.get('Content-Length') === '0'\r\n      ) {\r\n        return opts.responseStyle === 'data'\r\n          ? {}\r\n          : {\r\n              data: {},\r\n              ...result,\r\n            };\r\n      }\r\n\r\n      const parseAs =\r\n        (opts.parseAs === 'auto'\r\n          ? getParseAs(response.headers.get('Content-Type'))\r\n          : opts.parseAs) ?? 'json';\r\n\r\n      let data: any;\r\n      switch (parseAs) {\r\n        case 'arrayBuffer':\r\n        case 'blob':\r\n        case 'formData':\r\n        case 'json':\r\n        case 'text':\r\n          data = await response[parseAs]();\r\n          break;\r\n        case 'stream':\r\n          return opts.responseStyle === 'data'\r\n            ? response.body\r\n            : {\r\n                data: response.body,\r\n                ...result,\r\n              };\r\n      }\r\n\r\n      if (parseAs === 'json') {\r\n        if (opts.responseValidator) {\r\n          await opts.responseValidator(data);\r\n        }\r\n\r\n        if (opts.responseTransformer) {\r\n          data = await opts.responseTransformer(data);\r\n        }\r\n      }\r\n\r\n      return opts.responseStyle === 'data'\r\n        ? data\r\n        : {\r\n            data,\r\n            ...result,\r\n          };\r\n    }\r\n\r\n    const textError = await response.text();\r\n    let jsonError: unknown;\r\n\r\n    try {\r\n      jsonError = JSON.parse(textError);\r\n    } catch {\r\n      // noop\r\n    }\r\n\r\n    const error = jsonError ?? textError;\r\n    let finalError = error;\r\n\r\n    for (const fn of interceptors.error._fns) {\r\n      if (fn) {\r\n        finalError = (await fn(error, response, request, opts)) as string;\r\n      }\r\n    }\r\n\r\n    finalError = finalError || ({} as string);\r\n\r\n    if (opts.throwOnError) {\r\n      throw finalError;\r\n    }\r\n\r\n    // TODO: we probably want to return error and improve types\r\n    return opts.responseStyle === 'data'\r\n      ? undefined\r\n      : {\r\n          error: finalError,\r\n          ...result,\r\n        };\r\n  };\r\n\r\n  const makeMethodFn =\r\n    (method: Uppercase<HttpMethod>) => (options: RequestOptions) =>\r\n      request({ ...options, method });\r\n\r\n  const makeSseFn =\r\n    (method: Uppercase<HttpMethod>) => async (options: RequestOptions) => {\r\n      const { opts, url } = await beforeRequest(options);\r\n      return createSseClient({\r\n        ...opts,\r\n        body: opts.body as BodyInit | null | undefined,\r\n        headers: opts.headers as unknown as Record<string, string>,\r\n        method,\r\n        url,\r\n      });\r\n    };\r\n\r\n  return {\r\n    buildUrl,\r\n    connect: makeMethodFn('CONNECT'),\r\n    delete: makeMethodFn('DELETE'),\r\n    get: makeMethodFn('GET'),\r\n    getConfig,\r\n    head: makeMethodFn('HEAD'),\r\n    interceptors,\r\n    options: makeMethodFn('OPTIONS'),\r\n    patch: makeMethodFn('PATCH'),\r\n    post: makeMethodFn('POST'),\r\n    put: makeMethodFn('PUT'),\r\n    request,\r\n    setConfig,\r\n    sse: {\r\n      connect: makeSseFn('CONNECT'),\r\n      delete: makeSseFn('DELETE'),\r\n      get: makeSseFn('GET'),\r\n      head: makeSseFn('HEAD'),\r\n      options: makeSseFn('OPTIONS'),\r\n      patch: makeSseFn('PATCH'),\r\n      post: makeSseFn('POST'),\r\n      put: makeSseFn('PUT'),\r\n      trace: makeSseFn('TRACE'),\r\n    },\r\n    trace: makeMethodFn('TRACE'),\r\n  } as Client;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { ClientOptions } from './types.gen';\r\nimport { type Config, type ClientOptions as DefaultClientOptions, createClient, createConfig } from './client';\r\n\r\n/**\r\n * The `createClientConfig()` function will be called on client initialization\r\n * and the returned object will become the client's initial configuration.\r\n *\r\n * You may want to initialize your client this way instead of calling\r\n * `setConfig()`. This is useful for example if you're using Next.js\r\n * to ensure your client always has the correct values.\r\n */\r\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> = (override?: Config<DefaultClientOptions & T>) => Config<Required<DefaultClientOptions> & T>;\r\n\r\nexport const client = createClient(createConfig<ClientOptions>({\r\n    baseUrl: 'https://localhost:44389'\r\n}));"],"names":["jsonBodySerializer","body","_key","value","createSseClient","onSseError","onSseEvent","responseTransformer","responseValidator","sseDefaultRetryDelay","sseMaxRetryAttempts","sseMaxRetryDelay","sseSleepFn","url","options","lastEventId","sleep","ms","resolve","retryDelay","attempt","signal","headers","response","reader","buffer","abortHandler","done","chunks","chunk","lines","dataLines","eventName","line","parsed","data","parsedJson","rawData","error","backoff","getAuthToken","auth","callback","token","separatorArrayExplode","style","separatorArrayNoExplode","separatorObjectExplode","serializeArrayParam","allowReserved","explode","name","joinedValues","v","separator","serializePrimitiveParam","serializeObjectParam","valueOnly","values","key","PATH_PARAM_RE","defaultPathSerializer","path","_url","matches","match","replaceValue","getUrl","baseUrl","query","querySerializer","pathUrl","search","createQuerySerializer","array","object","queryParams","serializedArray","serializedObject","serializedPrimitive","getParseAs","contentType","cleanContent","type","checkForExistence","setAuthParams","security","buildUrl","mergeConfigs","a","b","config","mergeHeaders","mergedHeaders","header","iterator","Interceptors","id","index","fn","createInterceptors","defaultQuerySerializer","defaultHeaders","createConfig","override","createClient","_config","getConfig","setConfig","interceptors","beforeRequest","opts","request","requestInit","_fetch","result","parseAs","textError","jsonError","finalError","makeMethodFn","method","makeSseFn","client"],"mappings":"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"}